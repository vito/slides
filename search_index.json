{"index":{"location":"index.html","title":"Concourse Slides","text":"","depth":0,"section_tag":"index"},"v10":{"location":"v10.html","title":"Concourse v10","text":"Concourse v10Resources v2Resources v2 is now an idea of a 'generalized resource interface', decoupled from artifact versioning.\n\nUsers will be able to use v1 and v2 resources side-by-side, and users won't even have to upgrade to v2 to use new Concourse features.\n\nIt's just a refinement of the same idea.\n\nFor these slides, remember that 'version' is now called 'config fragment'.\n\nRIP SpacesBehind the name, there are a few great features:\n\n* Dynamically running jobs across 'spatial' change, i.e. branches and PRs.\n\n* \"Fanning in\" using passed constraints across spaces.\n\n* Automatically cleaning up spaces for closed PRs, etc.\n\nThese still make sense. So why is 'spaces' dead?\n\nOur first approach was to extend resources and jobs to support finding versions and running builds across spaces.\n\nThis approach proved to be strategically expensive.\n\nWe thought of it as one big feature, and we baked it into the entire stack, from the web UI down to the resource protocol.\n\nHaving a single feature touch so many things led to lot of second-guessing and many different iterations.\n\nCan we break this big feature up?\n\nRecently we were able to decouple 'Resources v2' from 'Spaces' by taking a completely different approach, leveraging composition instead of directly coupling them.\n\nDoing this was liberating: suddenly we could deliver two big features independently instead of all at once.\n\nCan we do the same for 'spaces'?\n\nLet's go on a journey.\n\nI've got a few features to propose, which I hope are independently useful.\n\nWhen they're used together, they become way more powerful.\n\nHang in there - the dots should connect as we go along!\n\nArchiving PipelinesPipelines can be archived when they are no longer needed.\n\nWhen archived, a pipeline becomes completely inactive, and its name can be used for later pipelines. This is basically a soft-delete.\n\n$ fly archive-pipeline -p pipeline-name\nThis is a pretty simple feature on its own, but it's also a precursor to \"instanced pipelines.\"\n\nSomeone actually started on a PR for this a while back. It doesn't seem too hard.\n\nAPI: small - support archiving/unarchiving, support re-using names of archived pipelines.\n\nUX: medium - 'dim' and/or stash away archived pipelines.\n\nCore: x-small - don't schedule archived pipelines.\n\nInstanced PipelinesPipeline templates can be \"instantiated\" with ((vars)) that also become part of the pipeline's identifier.\n\n$ fly set-pipeline -p release \\\n    -i version:5.3 \\\n    -c ci/pipelines/release.yml\nThis is a small UX change that allows simple pipeline hierarchies to form - 2 levels deep instead of N.\n\nAPI: medium? - allow multiple instances of same pipeline name with different vars.\n\nCore: x-small - schedule all pipeline instances.\n\nUX: medium - probably a lot of navigation UX to figure out, but hopefully simpler than 'spaces'.\n\nset_pipeline stepPipelines can be configured by using a new set_pipeline step in a build plan:\n\nplan:\n- get: ci\n- set_pipeline: concourse\n  file: ci/pipelines/concourse.yml\nThe pipeline will be set within the team running the build, and will start un-paused.\n\nThe set_pipeline step can be used to 'sync' all instances of a pipeline:\n\nplan:\n- get: ci\n- set_pipeline: concourse\n  file: ci/pipelines/concourse.yml\n- set_pipeline: release\n  file: ci/pipelines/release.yml\n  instance_vars: {version: 5.3}\n- set_pipeline: release\n  file: ci/pipelines/release.yml\n  instance_vars: {version: 5.2}\nA build which uses set_pipeline for setting instances determines the full set of active instances for the pipeline.\n\nAll other instances will be automatically archived when the build completes.\n\nThis way release pipelines will automatically become archived when they're no longer relevant.\n\nThis will be more important later!\n\nAPI: x-small - support parsing it as part of the build plan.\n\nCore: small - implement the step. medium once we do instance archiving.\n\nUX: small - support rendering the step.\n\nacross stepAn across step runs a given step across all versions returned by a resource check:\n\nacross: supported-ruby-images\nas: ruby\ndo:\n- task: unit\n  image: ruby\n  file: ci/tasks/unit.yml\nThe across step can be nested to do N-dimensional matrixes.\n\nBy composing these two steps and using instance_fragment , we now have pipeline matrixes:\n\nacross: concourse-branches\nas: branch\ndo:\n- set_pipeline: branch\n  instance_fragment: branch\n  file: ci/pipelines/branch.yml\nWhen a branch goes away, its instance will become archived.\n\nThe across step will support trigger: true. This way the build will fire on any change to the set.\n\nacross: concourse-branches\nas: branch\ntrigger: true\ndo:\n- set_pipeline: branch\n  instance_fragment: branch\n  file: ci/pipelines/branch.yml\nAPI: x-small - support it as part of the build plan.\n\nCore: medium/large - implement a new type of scheduling and triggering, similar to get step handling but for sets of versions. Construct a build plan that repeats the step with a get for each version.\n\nUX: medium - show all the steps, probably in some sort of tab UI. There's some prior art with attempts:.\n\nProjectsA project is a namespace for pipelines, resources, and tasks.\n\nA project is bootstrapped by a resource containing the project's configuration, along with its tasks, resources, and pipelines.\n\nMany projects may exist within a team.\n\nProjects are configured with fly set-project:\n\n$ fly -t ci set-project \\\n    --project booklit \\\n    --type git \\\n    --source uri=https://github.com/vito/booklit \\\n    --config-path ci\nThe --config-path flag identifies the sub-directory within the resource from which to load the project config.\n\nConcourse will check for new versions of the project and load the project's config, resources, tasks, etc.:\n\nci/project.yml\nci/tasks/test.yml\nci/resources/booklit.yml\nci/pipelines/booklit.yml\nPipelines shrink down to just job definitions, removing hundreds of lines of YAML. Separate files are much easier to work with.\n\nA minimal project configuration contains a name and a plan:\n\nname: booklit\nplan:\n- task: test\nThe project's plan: will run every time a new version of the project is found, with the project resource itself available under the configured name.\n\nKinda like Travis/Circle CI.\n\nProjects, when combined with the set_pipeline step, allow your entire project to be automated and reproducible.\n\nIt's a full blown build plan, you can even do pipeline templating if necessary:\n\nname: ci\nplan:\n- task: generate-template\n- set_pipeline: fancy-templated-pipeline\n  file: generated-pipeline/foo.yml\nPipelines within a project change in a few ways:\n\n* Every job will automatically have the project resource available to its build plan, just like the project's own plan.\n\n* Pipelines will no longer list their own resource definitions. Instead, there will be project-wide resource definitions.\n\n* Pipelines will be able to reference each other's jobs via passed constraints. This is the missing piece for 'spaces'.\n\nProjects define credential managers as var_sources:\n\nname: ci\n\nvar_sources:\n- type: vault\n  config: # ...\n\nplan: # ...\nThe proximity to plan: makes it easy to audit credential access within the project.\n\nAPI: medium - there's a new object owner in town, so I expect some API noise. Maybe we should invest in non-hierarchical URLs at this point?\n\nCore: medium/large - this is a bit of an epic, but it's at least grounded in well-understood ideas (i.e. build plans). I think there are interesting, relatively simple ways to design this.\n\nUX: medium/large - we'll need project builds to show up in the UI somewhere. And we'll probably want to think about any navigation implications.\n\nPutting it all together...Circling back to 'spaces', let's see how these features add up:\n\n* Dynamically running pipelines across branches and PRs: projects + across step + set_pipeline step.\n\n* \"Fanning in\" across spaces is possible with projects.\n\n* Automatically cleaning up spaces which no longer exist: instanced pipelines become automatically archived.\n\nname: booklit\nplan:\n- task: test\nfly set-project -p booklit -t git \\\n  -s uri=https://github.com/vito/booklit \\\n  -c ci\nThis should feel intuitive for smaller projects which may not need a sophisticated pipeline system. Concourse has been described as 'overkill' for such use cases - hopefully this bridges the gap.\n\nname: ci\nvar_sources:\n- type: vault\n  config: # ...\nplan:\n- set_pipeline: concourse\n- set_pipeline: prs\nIn this case it might make more sense for prs to be a separate project so it doesn't share the credential manager config.\n\nname: ci\nplan:\n- set_pipeline: concourse\n- across: release-branches\n  as: branch\n  do:\n  - set_pipeline: release\n    instance_fragment: branch\n- across: feature-branches\n  as: branch\n  do:\n  - set_pipeline: branch\n    instance_fragment: branch\nyour metaphor sucks...Ok, the Exodia metaphor is a little broken.\n\nWith Exodia, each card on its own is completely worthless until you have all five.\n\nThe entire point of this roadmap is that each feature is useful independently.\n\nA better metaphor would be \"Blue Eyes White Dragon\":\n\n{image: img/blue-eyes-white-dragon.png} {image: img/blue-eyes-white-dragon.png} {image: img/blue-eyes-white-dragon.png} = {image: img/blue-eyes-ultimate-dragon.png}\n\n...but we have five features, not three.\n\nAnd we all know how that turned out anyway.\n\n{image: img/yugi-exodia-head.jpg} {image: img/kaiba.png}\n\nOutcomesProjects accomplish a Travis/Circle CI -like workflow. For simpler projects this may be all you need.\n\nAt this point, the user will be introduced to resources, tasks, and build plans.\n\nIf and when they need to take the next step, then they can start using pipelines and adopt a \"git ops\" workflow.\n\nBy then, the only new concept is passed constraints.\n\nProjects allow pipelines to reference each other in passed constraints.\n\nThis way users can configure independent pipelines for 'matrix' style workflows, i.e. testing across IaaSes.\n\nThe set_pipeline step allows for pipelines to be configured as part of a build plan.\n\nAlong the way, we can deprecate the concourse-pipeline resource, which has two smelly problems:\n\n* authenticating with Concourse\n\n* keeping fly in sync with your Concourse version\n\nPipeline instances allow for a common pipeline template to use some of its ((vars)) as part of the pipeline identifier.\n\nThis removes a lot of the need for 'hierarchical pipelines', which has been trotted around as an idea for a long time.\n\nPipeline instances should feel less complicated than arbitrary hierarchies (depth 2 is simpler than depth N).\n\nThe across step is the true 'root' of spatial automation. And because it just happens within a single build, it's a lot easier to reason about.\n\nBy composing the across step with the set_pipeline step, the mechanics of spatial pipelines should also be pretty easy to reason about.\n\nFor a long while now 'spaces' has been thought of as one big feature with a whole lot of implications.\n\nBy thinking about it as the intersection of five smaller features, our roadmap is heavily de-risked.\n\n* Resources v2: let's finally implement this\n\n* set_pipeline step: deprecate concourse-pipeline resource\n\n* Projects: smoothen learning curve\n\n* Archiving pipelines: nice-to-have\n\n* Instanced pipelines: automatic archiving, figure out nav\n\n* across step: open the spatial floodgates\n\n* #523 Hierarchical pipelines\n\n* #1200 How do you use fly set-pipeline?\n\n* #1707 Spatial resource flows\n\n* #1994 Split pipelines up; simple templating\n\n* #3985 Stricter naming conventions\n\n* RFC #21 Team Project credential managers\n\n","depth":1,"section_tag":"v10"}}
