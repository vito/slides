{"index":{"location":"index.html","title":"Concourse Slides","text":"","depth":0,"section_tag":"index"},"v10":{"location":"v10.html","title":"Concourse v10","text":"Concourse v10set_pipeline stepPipelines can be configured by using a new set_pipeline step in a build plan:\n\nplan:\n- get: ci\n- set_pipeline: concourse\n  file: ci/pipelines/concourse.yml\nThe pipeline will be set within the team running the build.\n\nWith this we can deprecate the concourse-pipeline resource.\n\nacross stepAn across step runs a given step across all versions of a resource:\n\nacross: concourse-branch\ndo:\n- set_pipeline: branch\n  var_files:\n    branch_name: concourse-branch/name\nArchiving PipelinesPipelines can be archived when they are no longer needed.\n\nWhen archived, a pipeline becomes completely inactive, and its name can be used for later pipelines. This is basically a soft-delete.\n\n$ fly archive-pipeline -p pipeline-name\nThis is a pretty simple feature on its own, but it's also a precursor to \"instanced pipelines.\"\n\nInstanced PipelinesPipeline templates can be \"instantiated\" with vars that become part of the pipeline's identifier.\n\nset_pipeline: release\ninstance_vars:\n  version: 5.3\nA build sets all instances of a pipeline - any other instances that were not set by the build become auto-archived. (This will be important later.)\n\nProjectsA project is a resource containing config for tasks, resources, pipelines, and the project itself.\n\nProjects are configured with fly set-project:\n\nfly -t ci set-project \\\n  --name booklit \\\n  --type git \\\n  --source uri=https://github.com/vito/booklit \\\n  --path ci\nMany projects may exist within a team.\n\nConcourse will check for new versions of the project and load its config from a project.yml file.\n\nIt will then load up all tasks, resources, and pipelines defined within the project directory structure:\n\nci/project.yml\nci/tasks/test.yml\nThis allows pipelines to shrink down to just job definitions, removing hundreds of lines of YAML.\n\nA minimal project configuration contains a name and a plan:\n\nname: booklit\nplan:\n- task: test\nThe project's plan: will run every time a new version of the project is found. The build output will be visible in the UI.\n\nThe project's code will available to each build executed in the project under the project's name.\n\nProjects, when combined with the set_pipeline step, allow your entire project to be automated and reproducible:\n\nname: ci\nplan:\n- set_pipeline: concourse\n- task: generate-template\n- set_pipeline: fancy-templated-pipeline\n  file: generated-pipeline/foo.yml\n- set_pipeline: release-5.2.x\n  pipeline: release # pipelines/release.yml\n  vars: # ...\nPipelines within a project change in a few ways:\n\n* Every job will automatically have the project resource available to its build plan, just like the project's own plan.\n\n* Pipelines will no longer list their own resource definitions. Instead, there will be project-wide resource definitions.\n\n* Pipelines will be able to reference each other's jobs via passed constraints. This is the missing piece for 'spaces'.\n\nProjects define credential managers as var_sources:\n\nname: ci\n\nvar_sources:\n- type: vault\n  config: # ...\n\nplan: # ...\nThe proximity to plan: makes it easy to audit credential access within the project.\n\nPutting it all together...name: booklit\nplan:\n- task: test\nfly set-project -p booklit -t git \\\n  -s uri=https://github.com/vito/booklit\nThis should feel intuitive for smaller projects which may not need a sophisticated pipeline system. Concourse has been described as 'overkill' for such use cases - hopefully this bridges the gap.\n\nname: ci\nvar_sources:\n- type: vault\n  config: # ...\nplan:\n- set_pipeline: concourse\n- set_pipeline: prs\nThough in this case it might make more sense for prs to be a separate project so it doesn't share the credential manager config. (Or maybe we could have pipelines associated to credential managers?)\n\nname: ci\nplan:\n- set_pipeline: concourse\n- across: branch\n  resource: release-branches\n  do:\n    set_pipeline: release\n    instance_fragment: branch\n- across: branch\n  resource: feature-branches\n  do:\n    set_pipeline: branch\n    instance_fragment: branch\n...Ok, the Exodia metaphor is a little broken.\n\nWith Exodia, each card on its own is completely worthless until you have all five.\n\nThe entire point of this roadmap is that each feature is useful independently.\n\nA better metaphor would be \"Blue Eyes White Dragon\":\n\n= \n\n...but we have five features, not three.\n\nAnd we all know how that turned out anyway.\n\nLet's peel back the name for a second and see what 'spaces' really is:\n\n* Dynamically running pipelines across branches and PRs.\n\n* \"Fanning in\" across spaces - something that's impossible with pipelines.\n\n* Automatically cleaning up spaces which no longer exist.\n\n...and let's see how these features accomplish those goals:\n\n* Dynamically running pipelines across branches and PRs: projects + across step + set_pipeline step.\n\n* \"Fanning in\" across spaces: projects enable cross-pipeline passed constraints.\n\n* Automatically cleaning up spaces which no longer exist: instanced pipelines become automatically archived.\n\nOutcomesProjects accomplish a Travis/Circle CI -like workflow. For simpler projects this may be all you need.\n\nAt this point, the user will be introduced to resources, tasks, and build plans.\n\nIf and when they need to take the next step, then they can start using pipelines and adopt a \"git ops\" workflow.\n\nBy then, the only new concept is passed constraints.\n\nProjects allow pipelines to reference each other in passed constraints.\n\nThis way users can configure independent pipelines for 'matrix' style workflows, i.e. testing across IaaSes.\n\nThe set_pipeline step allows for pipelines to be configured as part of a build plan.\n\nAlong the way, we can deprecate the concourse-pipeline resource, which has two smelly problems:\n\n* authenticating with Concourse\n\n* keeping fly in sync with your Concourse version\n\nPipeline instances allow for a common pipeline template to use some of its ((vars)) as part of the pipeline identifier.\n\nThis removes a lot of the need for 'hierarchical pipelines', which has been trotted around as an idea for a long time.\n\nPipeline instances should feel less complicated than arbitrary hierarchies (depth 2 is simpler than depth N).\n\nThe across step is the true 'root' of spatial automation. And because it just happens within a single build, it's a lot easier to reason about.\n\nBy composing the across step with the set_pipeline step, the mechanics of spatial pipelines should also be pretty easy to reason about.\n\nFor a long while now 'spaces' has been thought of as one big feature with a whole lot of implications.\n\nBy thinking about it as the intersection of five smaller features, our roadmap is heavily de-risked.\n\n","depth":1,"section_tag":"v10"}}
