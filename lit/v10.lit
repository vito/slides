\title{Concourse v10}{v10}

\use-plugin{slides}
\styled{slides}

\title-slide{Concourse v10}{
  \youtube{YHRyirjO5rM}
}

\title-slide{RIP Spaces}{
  2017-2019

  we hardly knew ye
}

\detail{What was spaces?}{
  Behind the name, there are a few great features:

  \list{
    Dynamically running jobs across 'spatial' change, i.e. branches and PRs.
  }{
    "Fanning in" using \code{passed} constraints across spaces.
  }{
    Automatically cleaning up spaces for closed PRs, etc.
  }
}

\detail{Analysis paralysis}{
  Our first approach was to \bold{extend} resources and jobs to support
  finding versions and running builds across spaces.

  This approach proved to be strategically expensive.

  We thought of it as one big feature, and we baked it into the entire stack,
  from the web UI down to the resource protocol.

  Having a single feature touch so many things led to lot of second-guessing
  and many different iterations.
}

\detail{Learning to walk again}{
  Can we break this big feature up?

  Recently we were able to decouple 'Resources v2' from 'Spaces' by taking a
  completely different approach, leveraging composition instead of directly
  coupling them.

  Doing this was liberating: suddenly we could deliver two big features
  independently instead of all at once.

  Can we do the same for 'spaces'?
}

\detail{Hold my hand...}{
  Let's go on a journey.

  I've got a few features to propose, which I hope are independently useful.

  When they're used together, they become way more powerful.

  Hang in there - the dots should connect as we go along!
}

\title-slide{Archiving Pipelines}{
  \exodia{img/exodia-right-leg.png}
}

\detail{Archiving Pipelines}{
  Pipelines can be archived when they are no longer needed.

  When archived, a pipeline becomes completely inactive, and its name can be
  used for later pipelines. This is basically a soft-delete.

  \codeblock{sh}{{
  $ fly archive-pipeline -p pipeline-name
  }}

  This is a pretty simple feature on its own, but it's also a precursor to
  "instanced pipelines."
}

\detail{Archiving implications}{
  Estimate: medium

  Someone actually started on a PR for this a while back. It doesn't seem too
  hard.

  \bold{API}: support archiving/unarchiving, support re-using names of archived
  pipelines.

  \bold{UX}: 'dim' and/or stash away archived pipelines.

  \bold{Core}: don't schedule archived pipelines.
}

\title-slide{Instanced Pipelines}{
  \exodia{img/exodia-left-leg.png}
}

\detail{Instanced Pipelines}{
  Pipeline templates can be "instantiated" with vars that become part of the
  pipeline's identifier.

  \codeblock{yml}{{
  set_pipeline: release
  instance_vars:
    version: 5.3
  }}

  A build sets all instances of a pipeline - any other instances that were not
  set by the build become auto-archived. (This will be important later.)
}

\detail{Instanced Pipelines complexity}{
  Estimate: medium/large

  \bold{API}: allow multiple instances of same pipeline name with different
  vars.

  \bold{Core}: schedule all pipeline instances.

  \bold{UX}: support navigating to instances of a pipeline. (A bit of an
  understatemt.)
}

\title-slide{\code{set_pipeline} step}{
  \exodia{img/exodia-right-arm.png}
}

\detail{\code{set_pipeline} step}{
  Pipelines can be configured by using a new \code{set_pipeline} step in a
  build plan:

  \codeblock{yaml}{{
  plan:
  - get: ci
  - set_pipeline: concourse
    file: ci/pipelines/concourse.yml
  }}

  The pipeline will be set within the team running the build, and will start
  un-paused.

  We can then immediately deprecate the \code{concourse-pipeline} resource.
}

\detail{\code{set_pipeline} complexity}{
  Estimate: small

  \bold{API}: support it as part of the build plan.

  \bold{Core}: implement the step - shouldn't take too long.

  \bold{UX}: support rendering the step.
}

\title-slide{\code{across} step}{
  \exodia{img/exodia-left-arm.png}
}

\detail{\code{across} step}{
  An \code{across} step runs a given step across all versions returned by a
  resource \code{check}:

  \code{{
  \bold{across}: supported-ruby-images
  \bold{as}: ruby
  do:
  - task: unit
    image: ruby
    file: ci/tasks/unit.yml
  }}

  This is the beginning of 'spatial resources' which return a config fragment
  for each space.
}

\detail{\code{across} with \code{trigger}}{
  The next step is to support \code{trigger: true} - this way the build will
  fire on \italic{any} change to the set, i.e. fragments appearing or
  disappearing:

  \code{{
  across: concourse-branches
  as: branch
  \bold{trigger: true}
  do:
  - set_pipeline: branch
    instance_fragment: branch
    file: ci/pipelines/branch.yml
  }}
}

\detail{\code{across} complexity}{
  Estimate: medium/large

  \bold{API}: support it as part of the build plan.

  \bold{Core}: implement a new type of scheduling and triggering, similar to
  \code{get} step handling but for \italic{sets} of versions. Construct a build
  plan that repeats the step with a \code{get} for each version.

  \bold{UX}: show all the steps, probably in some sort of tab UI. There's some
  prior art with \code{attempts:}.
}

\title-slide{Projects}{
  \exodia{img/exodia-head.png}
}

\detail{What is a project?}{
  A project is a namespace for pipelines, resources, and tasks.

  A project is bootstrapped by a resource containing the project's
  configuration, along with its tasks, resources, and pipelines.

  Many projects may exist within a team.
}

\detail{\code{fly set-project}}{
  Projects are configured with \code{fly set-project}:

  \codeblock{sh}{{
    fly -t ci set-project \\
      --project booklit \\
      --type git \\
      --source uri=https://github.com/vito/booklit \\
      --path ci
  }}
}

\detail{Project structure}{
  Concourse will \code{check} for new versions of the project and load the
  project's config, resources, tasks, etc.:

  \codeblock{sh}{{
  ci/project.yml
  ci/tasks/test.yml
  ci/resources/booklit.yml
  ci/pipelines/booklit.yml
  }}

  Pipelines shrink down to just job definitions, removing hundreds of lines of
  YAML. Separate files are much easier to work with.
}

\detail{It's just a build plan!}{
  A minimal project configuration contains a \code{name} and a \code{plan}:

  \codeblock{yaml}{{
  name: booklit
  plan:
  - task: test
  }}

  The project's \code{plan:} will run every time a new version of the project
  is found, with the project resource itself available under the configured
  name.

  Kinda like Travis/Circle CI.
}

\detail{Git Ops}{
  Projects, when combined with the \code{set_pipeline} step, allow your entire
  project to be automated and reproducible:

  \codeblock{yaml}{{
  name: ci
  plan:
  - set_pipeline: concourse
  - task: generate-template
  - set_pipeline: fancy-templated-pipeline
    file: generated-pipeline/foo.yml
  - set_pipeline: release-5.2.x
    pipeline: release # pipelines/release.yml
    vars: # ...
  }}
}

\detail{Pipelines within projects}{
  Pipelines within a project change in a few ways:

  \list{
    Every job will automatically have the project resource available to its
    build plan, just like the project's own \code{plan}.
  }{
    Pipelines will no longer list their own resource definitions. Instead,
    there will be project-wide resource definitions.
  }{
    Pipelines will be able to reference each other's jobs via \code{passed}
    constraints. This is the missing piece for 'spaces'.
  }
}

\detail{Project-level creds}{
  Projects define credential managers as \code{var_sources}:

  \codeblock{yml}{{
  name: ci

  var_sources:
  - type: vault
    config: # ...

  plan: # ...
  }}

  The proximity to \code{plan:} makes it easy to audit credential access within
  the project.
}

\title-slide{Putting it all together...}{
  \exodia{img/exodia-together.jpg}
}

\detail{Spaces?}{
  Circling back to 'spaces', let's see how these features add up:

  \list{
    Dynamically running pipelines across branches and PRs: \bold{projects} +
    \bold{\code{across} step} + \bold{\code{set_pipeline} step}.
  }{
    "Fanning in" across spaces is possible with \bold{projects}.
  }{
    Automatically cleaning up spaces which no longer exist: \bold{instanced
    pipelines} become automatically \bold{archived}.
  }
}

\detail{Demo 1: simple project}{
  \code{{
  name: booklit
  plan:
  - task: test
  }}

  \codeblock{sh}{{
  fly set-project -p booklit -t git \\
    -s uri=https://github.com/vito/booklit
  }}

  This should feel intuitive for smaller projects which may not need a
  sophisticated pipeline system. Concourse has been described as 'overkill' for
  such use cases - hopefully this bridges the gap.
}

\detail{Demo 2: git ops project}{
  \code{{
  name: ci
  var_sources:
  - type: vault
    config: # ...
  plan:
  - \bold{set_pipeline}: concourse
  - \bold{set_pipeline}: prs
  }}

  Though in this case it might make more sense for \code{prs} to be a separate
  project so it doesn't share the credential manager config. (Or maybe we could
  have pipelines associated to credential managers?)
}

\detail{Demo 3: spatial pipelines}{
  \code{{
  \bold{name}: ci
  \bold{plan}:
  - \bold{set_pipeline}: concourse
  - \bold{across}: branch
    resource: release-branches
    do:
      \bold{set_pipeline}: release
      \bold{instance_fragment}: branch
  - \bold{across}: branch
    resource: feature-branches
    do:
      \bold{set_pipeline}: branch
      \bold{instance_fragment}: branch
  }}
}

\slide{Broken metaphor}{
  ...Ok, the Exodia metaphor is a little broken.

  With Exodia, each card on its own is completely worthless until you have all
  five.

  The entire point of this roadmap is that each feature is useful
  independently.
}

\detail{Better metaphor?}{
  A better metaphor would be "Blue Eyes White Dragon":

  \center{
    \exodia{img/blue-eyes-white-dragon.png}{small-card}
    \exodia{img/blue-eyes-white-dragon.png}{small-card}
    \exodia{img/blue-eyes-white-dragon.png}{small-card}
    =
    \exodia{img/blue-eyes-ultimate-dragon.png}{small-card}
  }

  ...but we have five features, not three.
}

\detail{Better metaphor?}{
  And we all know how that turned out anyway.

  \center{
    \exodia{img/yugi-exodia-head.jpg}{small-screen}
    \exodia{img/kaiba.png}{small-screen}
  }
}

\title-slide{Outcomes}{
  What will we have achieved?
}

\detail{Scales with more projects}{
  \bold{Projects} accomplish a Travis/Circle CI -like workflow. For simpler
  projects this may be all you need.

  At this point, the user will be introduced to resources, tasks, and build
  plans.

  If and when they need to take the next step, then they can start using
  pipelines and adopt a "\code{git} ops" workflow.

  By then, the only new concept is \code{passed} constraints.
}

\detail{Fan-in across pipelines}{
  \bold{Projects} allow pipelines to reference each other in \code{passed}
  constraints.

  This way users can configure independent pipelines for 'matrix' style
  workflows, i.e. testing across IaaSes.
}

\detail{Pipeline automation}{
  The \bold{\code{set_pipeline} step} allows for pipelines to be configured as
  part of a build plan.

  Along the way, we can deprecate the \code{concourse-pipeline} resource, which
  has two smelly problems:

  \list{
    authenticating with Concourse
  }{
    keeping \code{fly} in sync with your Concourse version
  }
}

\detail{Pipeline sub-naming}{
  \bold{Pipeline instances} allow for a common pipeline template to use some of
  its \code{((vars))} as part of the pipeline identifier.

  This removes a lot of the need for 'hierarchical pipelines', which has been
  trotted around as an idea for a long time.

  Pipeline instances should feel less complicated than arbitrary hierarchies
  (depth 2 is simpler than depth N).
}

\detail{Build/pipeline matrixes}{
  The \bold{\code{across} step} is the true 'root' of spatial automation. And
  because it just happens within a single build, it's a \italic{lot} easier to
  reason about.

  By composing the \code{across} step with the \bold{\code{set_pipeline} step},
  the mechanics of spatial pipelines should also be pretty easy to reason
  about.
}

\detail{De-risked roadmap}{
  For a long while now 'spaces' has been thought of as one big feature with a
  whole lot of implications.

  By thinking about it as the intersection of five smaller features, our
  roadmap is heavily de-risked.
}

\slide{References}{
  \list{
    \link{#523}{https://github.com/concourse/concourse/issues/523} Hierarchical pipelines
  }{
    \link{#1200}{https://github.com/concourse/concourse/issues/1200} How do you use \code{fly set-pipeline}?
  }{
    \link{#1707}{https://github.com/concourse/concourse/issues/1707} Spatial resource flows
  }{
    \link{#1994}{https://github.com/concourse/concourse/issues/1994} Split pipelines up; simple templating
  }{
    \link{#3985}{https://github.com/concourse/concourse/issues/3985} Stricter naming conventions
  }{
    \link{RFC #21}{https://github.com/concourse/rfcs/pull/21} \strike{Team} Project credential managers
  }
}
